# TPPmark16

## 3.1 依存型プログラミング的な表現

引数として次の 3 つを受け取り、`lst` の `i` 番目のリストの `j` 番目要素を削除した結果を返す関数 `remove_lst` を構築せよ。

1. リストのリスト `lst`
2. 整数 `i`
3. 整数 `j`

その際、以下の条件を保証すること（先頭インデックスは 0 とする）。

1. `lst` の `i` 番目のリストが存在する。
2. `i` 番目リストの `j` 番目要素が存在する。
3. 返却されるリストの長さは、`i` 番目のみ 1 だけ短く、その他は変わらない。

## 3.2 論理的な表現

同じく `lst`, `i`, `j` を与えられたとき、`lst` の `i` 番目リストの `j` 番目要素が取得可能ならば、次の性質を満たすリストが（唯一）存在することを示せ。

- `i` 番目のリストは `j` 番目要素を取り除いた形になっている。
- それ以外のリストは元のままである。
- 返却される各リストの長さは、`i` 番目だけが元より 1 だけ短く、そのほかは変化しない。

ここでもインデックスはすべて 0 始まりとする。

## 3.3 OCaml によるプログラム

依存型プログラミング的な仕様を OCaml で（安全性チェックなしの形で）書いたものが `remove.ml` である。プログラム中には 2 箇所 `raise CannotHappen` が現れる。これらの例外が発生し得ないことを、引数に適切な条件を課すことで保証し、さらに返り値のリスト群の長さが指定通りであることを示すのが本課題の趣旨である。

`lst` の長さを `n` とし、各リストの長さを `m0, ..., mn-1` とする。`i` は `0` 以上 `n - 1` 以下、`j` は `0` 以上 `mi - 1` 以下の整数に限定すれば例外は避けられそうだが、`j` の範囲が `i` に依存する点に注意。これをうまく型あるいは条件として表現できるかが問題の核心である。

## 3.4 背景

項の単一化では、メタ変数に項を代入する操作が現れる。たとえば SK 論理式 `S X K (Y K Z) K` においてメタ変数 `Y` に `S` を代入すると `S X K (S K Z) K` となり、メタ変数集合は `[X, Y, Z]` から `[X, Z]` へ減少する。これは `lst` の先頭のリストから 1 要素を削る操作に相当する。

ここでは「SK 論理式」という一種の項のみを扱ったが、実際には複数種類の項が相互再帰するケースがあり得る。項が `n` 種類あり、各種類に対応するメタ変数が `m0, ..., mn-1` 個存在するとしよう。このとき、`i` 番目の種類の `j` 番目メタ変数に代入を行うと、その要素だけが削除された集合になる。

著者はこのようにメタ変数の数を管理しながら項の単一化を実装しようとしている。しかし項の種類が複数で相互再帰する状況では、どのように設計すべきか分からなくなり、参加者からの知恵を求めている。
